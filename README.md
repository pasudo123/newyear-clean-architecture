## 클릭 아키텍처 : 소프트웨어 구조와 설계의 원칙
* 책을 읽고, 인상적인 구절을 남긴다.

---
## 4장 구조적 프로그래밍
p.35 : 테스트
> 프로그램이 잘못되었음을 테스트를 통해 증명할 수는 있지만, 프로그램이 맞다고 증명할 수 없다.   
> 테스트에 충분한 노력을 들였다면, 테스트가 보장할 수 있는 것은 프로그램이 목표에 부합할 만큼은 충분히 참이라고 여길 수 있게 해주는 것이 전부다.

---
## 5장 객체 지향 프로그래밍
p.38 ~ p.51 : 캡슐화/상속/다형성
* 객체지향은 캡슐화를 강제하지 않음.
* 객체지향만 캡슐화를 할 수 있는 것이 아님.
* 객체지향이 아니더라도 충분히 타 언어에서 상속 흉내가 가능.
* 객체지향에서는 상속을 편하게 하도록 기능을 제공.
* 다형성을 통해, 고수준모듈과 저수준모듈의 독립성을 보장받을 수 있음.

---
## 6장 함수형 프로그래밍
p.58 : 불변성과 아키텍처
* 아키텍처를 고려할 때, 변수의 가변성을 고려해야 한다.
  * 아래의 문제가 모두 가변변수로 인해서 발생한다.
    * 경합조건 (race condition)
    * 교착상태 (deadlock)
    * 동시 업데이트 (concurrent update)
* 아키텍트라면 동시성 문제에 관심을 가져야 한다.

---
## 7장 SRP : 단일 책임 원칙
* SRP 는 모듈은 반드시 하나의, 단 하나의 일만 해야한다 (X)
  * `잘못된 이해를 하고 있었음.` -> 원래는 함수가 단 하나의 일만 해야한다는 원칙임
* SRP 는 단일 모듈의 변경의 이유가 오직 하나뿐이어야 한다. (O)
  * 변경의 이유란?, 사용자와 이해관계자를 가리킨다.
    * 한 명의 사용자 혹은 한 명 이상의 특정한 이해관계자에 대해서만 책임을 가진다.
  * 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임을 가져야 한다.
  * 액터(actor) 란?, 한 명 이상의 특정한 집단을 가리킨다.
* 서로 다른 액터를 뒷받침 하는 코드를 서로 분리하는 것.

> 문득, 실무가 생각난다.   
> DDD 의 계층형 아키텍처를 고려하면 결국 아래와 같은 순으로 하는게 좋지 않을까?   
> controller -> application service -> interactor -> infra/repository

---
## 8장 OCP : 개방-폐쇄 원칙
* 소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이 때 개체를 변경해서는 안된다.
* `추이종속성 (transitive dependency)` 을 가지면 안된다.
  * 클래스 A 가 클래스 B 에 의존한다.
  * 클래스 B 가 클래스 C 에 의존한다.
  * 결과적으로 클래스 A 가 클래스 C 에 의존한다.

---
## 9장 LSP : 리스코프 치환 원칙
p.82 ~ p.86 
* 책을 한번 더 짧게 읽자.

---
## 10장 ISP : 인터페이스 분리 원칙
* 책을 한번 더 짧게 읽자.
* 필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 해로운 일이다.
* 소스 코드 의존성의 경우 이는 분명한 사실인데, 불필요한 재컴파일과 재배포를 강제하기 때문이다.

---
## 11장 DIP : 의존성 역전 원칙
* 정적 타입 언어에서 오직 인터페이스나 추상 클래스 같은 추상적인 선언만을 참조해야 한다.
  * 구체적인 대상에는 절대로 의존해서는 안된다.

안정화된 추상화
* 변동성이 큰 구체 클래스를 참조하지 말라
  * 대신 추상 인터페이스를 참조하라
* 변동성이 큰 구체 클래스로부터 파생하지 말라
  * 상속은 신중하게.
  * 정적 타입 언어에서 상속은 소스 코드에 존재하는 모든 관계 중 가장 강력한 동시에 뻣뻣해서 변경하기 어렵다.
    * `해당 내용을 읽다보니, 상속에 관해 쓴 과거 블로그 글이 떠오름` : [링크](https://pasudo123.tistory.com/446)

팩토리
* 소스 코드 의존성은 제어흐름과 반대 방향으로 역전된다. 이러한 이유로 이 원칙을 의존성 역전이라고 부른다.

---
## 14장 컴포넌트 결합
### 1. ADP : 의존성 비순환 원칙
* 컴포넌트 의존성 그래프에 순환이 있어서는 안된다.
* 순환이 없는 컴포넌트 의존성 그래프는, 의존성 관계를 따라가면 최초의 컴포넌트로 되돌아갈 수 없다. (p.118)
  * 해당 구조는 비순환 방향그래프 : DAG (Directed Acyclic Graph) 다.
* 순환 끊기
  * 의존성 역천 원칙 : DIP 를 이용한다.
  * 두 컴포넌트간의 의존성 사이에 별도의 의존성을 가질 수 있는 컴포넌트를 심어준다. (p.122)
* `순환이 발생하면 어떤 식으로든 끊어야 한다.`
  * 결과적으로 새로운 컴포넌트를 생성하거나 의존성 구조가 더 커질 수 있음을 의미한다.

### 2. SDP : 안정된 의존성 원칙
* 안정성의 방향으로 (더 안정된 쪽에) 의존하라
* 설계는 정적일 수 없다. 설계를 유지하다 보면 변경은 불가피하다.
* 당신이 모듈을 만들 때는 변경하기 쉽도록 했지만, 이 모듈에 누군가가 의존성을 매달아 버리면 당신의 모듈도 변경하기 어려워진다.
* 안정성
  * 무언가가 안정적 : `쉽게 움직이지 않는`
  * 소프트웨어 컴포넌트를 변경하기 어렵게 만드는 확실한 방법 하나는 수많은 컴포넌트가 해당 컴포넌트를 의존하게 만드는 것이다.
* 안정성과 불안정성 (p.126 그림 참고)
* 모든 컴포넌트가 안정적이어야 하는 것은 아니다. (p.128)
  * 모든 컴포넌트가 최고로 안정적인 시스템이라면 변경이 불가능하다. 이는 바람직한 상황이 아니다.
  * 불안정한 컴포넌트도 있고, 안정적인 컴포넌트도 있어야 한다.

### 3. SAP : 안정된 추상화 원칙
* 컴포넌트는 안정된 정도만큼만 추상화되어야 한다.
* 컴포넌트가 최고로 안정된 상태이면서도 동시에 변경에 충분히 대응할 수 있을 정도로 유연하게 만들 수 있을까?
  * 해답은 개방폐쇄 원칙 (OCP) 에서 찾을 수 있다.
* 안정된 추상화 원칙
  * 안정된 추상화 원칙은 안정성과 추상화정도 사이의 관계를 정의한다.
  * 의존성은 추상화의 방향으로 향하게 된다.
* 추상화 정도 측정하기 (p.132)
  * `해당 내용은 지표 계산이라 따로 책을 읽어본다.`

---
## 15장 아키텍처란
* 아키텍처의 주된 목적은 시스템의 생명주기를 지원하는 것이다.
* 아키텍처의 궁극적인 목표는 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성은 최대화하는 데 있다.
   
### 선택사항 열어두기 (p.146 ~ p.147)
* 소프트웨어를 부드럽게 유지하는 방법은 선택사항을 가능한 한 많이, 그리고 가능한 한 오랫동안 열어두는 것이다.
* 그렇다면 열어둬야 할 선택사항이란 무엇일까? 그것은 바로 중요치 않은 세부사항이다.
* 모든 소프트웨어 시스템은 주요한 두 가지 구성요소로 분해할 수 있다.
  * 정책 (policy) : 정책이란 시스템의 진정한 가치가 살아 있는 곳이다.
  * 세부사항 
* 아키텍트의 목표는 시스템에서 `정책을 가장 핵심적인 요소로 식별` 하고, `동시에 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는 데 있다.`
* 이를 통해서 세부사항을 결정하는 일은 미루거나 연기할 수 있게 된다.
* 결과적으로 세부사항에 몰두하지 않은 채 고수준의 정책을 만들 수 있다면, 이러한 세부사항에 대한 결정을 오랫동안 미루거나 연기할 수 있다.
* `좋은 아키텍트는 결정되지 않은 사항의 수를 최대화한다.`
  * 세부사항에 대한 결정을 가능한 한 오랫동안 미룰 수 있는 방향으로 정책을 설계한다.

---
## 16장 독립성
### 선택사항 열어놓기
* 선택사항을 가능한 한 많이, 그리고 가능한 한 오랫동안 열어 둘 수 있게 해준다.
* 좋은 아키텍처는 선택사항을 열어 둠으로써, 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 한다.
 
### 중복 (p.163)
* 중복에도 여러 종류가 있다.
* 진짜 중복
  * 한 인스턴스가 변경되면, 동일한 변경을 그 인스턴스의 모든 복사본에 반드시 적용해야 한다.
* 거짓된 또는 우발적인 중복
  * 중복으로 보이는 두 코드 영역이 각자의 경로로 발전한다면, 즉 서로 다른 속도와 다른 이유로 변경된다면 이 두 코드는 진짜 중복이 아니다.
* 자동반사적으로 중복을 제거해버리는 잘못을 저지르는 유혹을 떨쳐내라, 중복이 진짜 중복인지 확인하라

### 결합 분리 모드 (다시) (p.164 : 개인적으로 좋은 챕터였다.)
* 동일프로젝트 소스코드 / 컴포넌트 jar 임포트 영역 / 격리된 서비스로서의 존재
* 모놀리틱 -> 컴포넌트 분리 -> 서비스 분리 -> 컴포넌트 분리 -> 모놀리틱 

---
## 17장 경계 : 선 긋기
* 아키텍트의 목표는 필요한 시스템을 만들고 유지하는 데 드는 인적 자원을 최소화하는 것이라는 사실을 상기한다.
* 그렇다면 인적 자원의 효율을 떨어뜨리는 요인은 무엇일까? 바로 결합(coupling) 이다. 특히 너무 일찍 내려진 결정에 따른 결합이다.
* (p.176) (중략...) 경계선을 긋는 행위는 결정을 늦추고 연기하는 데 도움이 되었고, 궁극적으로는 시간을 엄청나게 절약해주었으며, 골치를 썩지 않게 해주었다.

### 어떻게 선을 그을까? 그리고 언제 그을까? (p. 176)
* 업무규칙이 데이터베이스에 신경쓰지 않아야 한다.
* 데이터베이스는 업무규칙이 간접적으로 사용할 수 있는 도구다. 업무 규칙은 스키마, 쿼리 언어 또는 데이터베이스와 관련된 나머지 세부사항에 대해 어떤 것도 알아서는 안된다.
  * `도메인 규칙이 중요하다. 데이터 드리븐 개발이 아닌, 도메인 드리븐 개발이 되어야 하는 이유? 라고 생각이 든다.`
  * 데이터베이스는 거들 뿐, 실제 중요한 로직의 처리는 비즈니스에서 해야한다. `레거시들에서 프로시저를 거둬내는 이유도 여기에 있지 않을까? 싶다.`

### 플러그인 아키텍처 (p.181 : 여기 내용이 읽을만하다.)
* 업무규칙에 플러그인 형태로 가기
  * GUI --> Business Rules  
  * DB --> Business Rules
  * 위 두 표현에서 결과적으로 Business Rules 는 독립적이다.

--- 
## 19장 정책과 수준
* 소프트웨어 시스템이란 정책을 기술한 것이다. 실제로 컴퓨터 프로그램의 핵심부는 이게 전부다. 컴퓨터 프로그램은 각 입력을 출력으로 변환하는 정책을 상세하게 기술한 설명서다.
* 저수준의 컴포넌트가 고수준 컴포넌트에 의존하도록 설계되어야 한다.
* 모든 소스코드 의존성 방향이 고수준 정책을 향할 수 있도록 정책을 분리했다면 변경의 영향도를 줄일 수 있다.
  * 저수즌의 컴포넌트가 고수준 컴포넌트에 플러그인되어야 한다는 관점을 바라볼 수도 있다.

### 결론
* 해당 18장에서 설명한 것은 앞선 원칙을 모두 포함한다.

--- 
## 20장 업무 규칙
* 업무규칙은 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차다.
* 엄밀히 말해서, 컴퓨터상에 구현여부와 상관 없다. -> `실제 현실세계의 도메인 규칙을 의미하는 것이 아닐까? 생각이 든다.`

### 유스케이스
* 유스케이스는 사용자가 제공해야 하는 입력, 사용자에게 보여줄 출력, 그리고 해당 출력을 생성하기 위한 처리 단계를 기술한다.
* 엔티티 내의 핵심 업무 규칙과는 반대로, 유스케이스는 애플리케이션에 특화된 업무 규칙을 설명한다.
* `유스케이스는 시스템이 사용자에게 어떻게 보이는지를 설명하지 않는다.`
* 왜 엔티티는 고수준?, 유스케이스는 저수준인가? (p. 203)
  * 해당 시스템의 입력과 출력에 보다 가깝게 유스케이스는 위치하기 때문이다.
  * 유스케이스는 엔티티(고수준) 에 의존한다.
  * 반면에 엔티티는 유스케이스(저수준) 에 의존하지 않는다.

---
## 21장 소리치는 아키텍처 (p.207)
* 소프트웨어 아키텍처는 시스템의 유스케이스를 지원하는 구조라고 지적했다.
  * 결과적으로 소프트웨어 애플리케이션의 아키텍처도 애플리케션의 유스케이스에 대해 소리쳐야 한다.
    * ex) 이건 재고관리 시스템이야 !!, 이건 헬스 케어 시스템이야 !!

### 아키텍처의 목적
* 좋은 아키텍처는 유스케이스를 그 중심에 두기 때문에, 프레임워크나 도구, 환경에 전혀 구애받지 않고 유스케이스를 지원하는 구조를 아무런 문제없이 기술할 수 있다.
* 좋은 아키텍처는 프로젝트의 훨씬 후반까지 레일스, 스프링, 하이버네이트, 톰캣, MySQL 에 대한 결정을 하지 않아도 되도록 해준다.
  * 지엽적인 관심사에 대한 결합은 분리시킨다. -> `세부사항은 나중에 구현한다.`

### 테스트하기 쉬운 아키텍처
* 프레임워크를 전혀 준비하지 않더라도 필요한 유스케이스 전부에 대해 단위 테스트를 할 수 있어야 한다.
* 테스트를 돌리는 데 웹 서버가 반드시 필요한 상황이 있어서는 안된다.
* 데이터베이스가 반드시 연결되어 있어야만 테스트를 돌릴 수 있어서도 안된다.
* 엔티티 객체는 반드시 오래된 방식의 간단한 객체 Plain Old Object 여야 한다.
* 프레임워크나 데이터베이스, 또는 여타 복잡한 것들에 의존해서는 안된다.
  
